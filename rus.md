# Grunt для тех, кто считает штуки вроде Grunt странными и сложными

Разработчикам-фронтендерам часто советуют делать определённые вещи:

*   **Работать с настолько маленькими кусками CSS и JavaScript**, насколько это
    имеет смысл, а затем объединять их для продакшна.

*   **Сжимать CSS и минифицировать JavaScript** с целью сделать файлы на
    продашне как можно меньше по размеру.

*   **Оптимизировать изображения**, чтобы уменьшить размеры файлов без потерь в
    качестве.

*   **Использовать Sass** для написания CSS из-за всех полезных абстракций,
    которые он позволяет использовать.


Конечно, этот список не полон, но это такие вещи, которые делать необходимо.
Вы можете называть их *задачами*.

Бьюсь об заклад, Вы слышали про [Grunt][1]. Что ж, Grunt — это утилита для
*выполнения задач*. Grunt может делать все эти вещи для Вас. Стоит лишь
установить его, что кстати не так уж и сложно, и эти вещи будут происходить
автоматически, так что про них даже не придётся вспоминать.

Но посмотрим правде в глаза: Grunt — одна из тех новомодных штучек, которой
пользуются все эти крутые парни, но которая на первый взгляд выглядит странно
и пугающе. Я Вас понимаю. И эта статья для Вас.

## Пресекаем некоторые заблуждения в зародыше

Возможно, Вы *слышали* про Grunt, но никогда с ним не работали. Я уверен, это
относится ко многим из вас. Вероятно, какие-то из этих загвоздок относятся к
Вам.

### Мне не нужно то, что делает Grunt

Вообще-то, возможно, что оно Вам и нужно. Посмотрите на тот список сверху. Эти
вещи не просто неплохо было бы иметь. Они — жизненно важная часть разработки
сайтов в наши дни. Если Вы их уже делаете, это замечательно. Вероятно, Вы
используете для этого разнообразные утилиты. Grunt помогает собрать их все,
так сказать, под одной крышей. А если Вы их ещё не используете, то Вам,
возможно, стоило бы, и Grunt может с этим помочь. А потом, когда Вы будете их
использовать, Grunt может делать для Вас ещё большее, что, в общем-то, будет
означать, что Вы лучше делаете свою работу.

### Grunt работает на Node.js, я не знаю Ноду

Вам и не надо знать Ноду. Точно так же, как Вам не нужно знать Ruby, чтобы
пользоваться Sass. Или PHP, чтобы пользоваться WordPress. Или C++, чтобы
пользоваться Microsoft Word.

### Вещи, которые делает Grunt, я и так могу сделать, по-другому

Они все собраны в одном месте, настроены так, что запускаются автоматически
когда понадобятся, и есть у каждого, кто работает над проектом? Вряд ли, рискну
предположить.

### Grunt — консольная программа, а я всего лишь дизайнер

А я тоже дизайнер. Я предпочитаю пользоваться приложениями с графическими
интерфейсами, если могу их достать. Но я не думаю, что это произойдет с Grunt.

Степень, в которой придется работать с командной строкой, такая:

1.  Перейти в папку с проектом.
2.  Напечатать `grunt` и нажать **Return**.

После установки, которая, повторюсь, не такая уж сложная.

## Хорошо. Устанавливаем Grunt

Node.js является необходимым условием для установки Grunt. Если Node у Вас
не установлен, не беспокойтесь, это очень легко. Вы просто скачиваете
установочник и запускаете его. Щёлкните на большой кнопке **Install**
[на сайте Node.js][2].

Grunt устанавливается на каждый проект отдельно. Перейдите в папку проекта.
Требуется небольшой файл под названием *package.json* в корне. Вы можете его
просто создать и положить туда.

![package.json в корне проекта][3]

Содержимое этого файла должно быть таким:

    {
      "name": "example-project",
      "version": "0.1.0",
      "devDependencies": {
        "grunt": "~0.4.1"
      }
    }


Вы вполне можете поменять название проекта и версию, главное, `devDependencies`
должно остаться таким же, как есть.

Это то, как Node разруливает зависимости. В Node есть пакетный менеджер под
разванием [npm][4].

Как только *package.json* будет на месте, откройте терминал, и перейдите в Вашу
папку. Те, кто мало смыслят в терминале, вроде меня, делают это примерно так:

![Колхозный способ смены папки в терминале][5]

Затем запустите команду:

    npm install

После того, как эта команда отработает, в проекте появится новая папка с именем
*node_modules*.

![Пример папки node_modules][6]

Другие файлы, что Вы там видите, *README.md* и *LICENSE*, находятся там потому
что я собираюсь выложить этот проект [на Github][7], и там это просто так
принято.

Последний шаг установки — установить Grunt CLI (command line interface,
«интерфейс командной строки»). Это то, что заставляет в терминале работать
команду `grunt`. Без неё запуск `grunt` вернёт ошибку вроде «Команда или файл не
найдена». Она устанавливается отдельно по причинам эффективности. Иначе, если бы
у Вас был десяток проектов, пришлось бы устанавливать десять копий GruntCLI.

Это опять одна строчка. Просто запустите эту команду в терминале:

    npm install -g grunt-cli

После этого следует закрыть и открыть заново окно терминала. Это вообще хороший
подход для того, чтобы убедиться, что всё работает. Это вроде того, как раньше
надо было перезагрузить компьютер после установки новой программы.

## Делаем так, чтобы Grunt объединял файлы

Представим, что в нашем проекте есть три отдельных файла JavaScript:

1.  ***jquery.js*** – Библиотека, которую мы используем.
2.  ***carousel.js*** – Плагин для jQuery, который мы используем.
3.  ***global.js*** – Написанный нами файл JavaScript, где мы настраиваем и
    вызываем плагин.

На продакшн-сервере нам надо объединить все эти файлы в один для улучшения
производительности (один запрос лучше, чем три). Нам нужно сказать Grunt, чтобы
он это для нас сделал.

Но постойте. Grunt на самом деле ничего сам по себе не делает. Помните же,
Grunt — это утилита для *выполнения* задач. А сами задачи нам придется добавить.
Пока что мы ещё не настроили Grunt, чтобы он что-либо делал, поэтому давайте
этим займёмся.

Официальный плагин Grunt для объединения файлов — [grunt-contrib-concat][8]

    npm install grunt-contrib-concat --save-dev

Приятная особенность такого способа установки в том, что Ваш файл *package.json*
будет автоматически обновлён, и в него пропишется новая зависимость. Откройте
его и убедитесь. Там появится новая строка:

    "grunt-contrib-uglify": "~0.2.2"

Вот теперь мы готовы использовать этот плагин. А чтобы его использовать, нам
нужно начать настраивать Grunt и объяснять ему, что делать.

Указать Grunt, что ему делать, можно при комощи конфигурационного файла с
названием *Gruntfile.js*.

Точно так же, как и файл *package.json*, наш *Gruntfile.js* находится в особом
формате, который должен быть в точности правильным. Я бы не стал заморачиваться
по поводу того, что значит в нём каждое слово. Просто взгляните на формат:

    module.exports = function(grunt) {
    
        // 1. Вся настройка находится здесь
        grunt.initConfig({
            pkg: grunt.file.readJSON('package.json'),
    
            concat: {
                // 2. Настройка для объединения файлов находится тут
            }
    
        });
    
        // 3. Тут мы указываем Grunt, что хотим использовать этот плагин
        grunt.loadNpmTasks('grunt-contrib-concat');
    
        // 4. Тут указываем, что делать, когда мы вводим «grunt» в терминале
        grunt.registerTask('default', ['concat']);
    
    };


Теперь нам нужно создать этот конфигурационный файл. Документация может быть
ошеломляющей. Давайте сосредоточимся на простеньком [примере][9].

Помните, у нас есть три файла JavaScript, которые мы пытаемся объединить. Мы
перечислим пути к ним в `src` в качестве массива с путями к файлам (как строки
в кавычках), и затем мы укажем файл назначения как `dest`. Файл назначения не
обязательно должен уже существовать. Он будет создан, когда эта задача будет
запущена и склеит все файлы в один.

И *jquery.js*, и *carousel.js* являются библиотеками. Мы, скорее всего, не
станем их трогатье. Так что, для порядка в проекте, мы будем держать их в папке
*/js/libs/*. Файл *global.js* — то, где мы пишем наш собственный код, поэтому он
будет находиться прямо в папке */js/*. Теперь скажем Grunt, как находить все эти
файлы и склеивать их в один файл *production.js*, названный так, чтобы показать,
что он будет использоваться на настоящем, живом сайте.

    concat: {
        dist: {
            src: [
                'js/libs/*.js', // Все JS в папке libs
                'js/global.js'  // Конкретный файл
            ],
            dest: 'js/build/production.js',
        }
    }

**Примечание:** далее в этой статье будут приводиться такие же небольшие кусочки
конфигурационного кода, как этот. Их цель — обратить внимание на важные места,
но поначалу Вы можете не понять, как каждый кусочек вставлен в большой файл.
Если Вы запутаетесь, и Вам нужно будет посмотреть на них в контексте,
просмотрите [полный файл конфигурации][10].

Когда конфигурация `concat` окажется на своем месте, откройте терминал и
запустите команду:

    grunt

и смотрите, что произойдёт! *production.js* будет создан, и он будет
превосходным объединением трёх файлов. Для меня это был такой момент «ага!».
Почувствуйте силу, наполняющую Ваши вены. Давайте сделаем побольше таких штук!

## Делаем так, чтобы Grunt минифицировал JavaScript

Мы проделали столько дел для подготовки, и добавить новую задачу для Grunt
теперь относительно легко. Всё, что нам надо сделать, это:

1.  Найти плагин для Grunt, который делает, что нам надо;
2.  Изучить стиль конфигурации этого плагина;
3.  Написать эту конфигурацию, чтобы плагин смог работать с нашим плагином.

Официальный плагин для минификации кода — [grunt-contrib-uglify][11]. Точно так
же, как и в прошлый раз, мы запускаем команду `npm`, чтобы запустить его.

    npm install grunt-contrib-uglify --save-dev

Затем изменяем *Gruntfile.js*, чтобы плагин загружался:

    grunt.loadNpmTasks('grunt-contrib-uglify');

А после конфигурируем его:

    uglify: {
        build: {
            src: 'js/build/production.js',
            dest: 'js/build/production.min.js'
        }
    }

Обновим задачу по умолчанию (`default`), чтобы запускать ещё и минификацию:

    grunt.registerTask('default', ['concat', 'uglify']);

Очень-очень похоже на то, как настраивалось объединение файлов, верно?

Запустите `grunt` в терминале и получите немного изысканно минифицированного
JavaScript:

![Minified JavaScript][12]

*production.min.js* — тот самый файл, который мы будем подключать в
*index.html*.

## Делаем так, чтобы Grunt оптимизировал наши изображения

Теперь, когда мы уже освоили процесс, нужно лишь пройти его ещё раз по шагам.
Официальный плагин Grunt для оптимизации изображений —
[grunt-contrib-imagemin][13]. Установим его:

    npm install grunt-contrib-imagemin --save-dev

Зарегистрируем в *Gruntfile.js*:

    grunt.loadNpmTasks('grunt-contrib-imagemin');

Настроим:

    imagemin: {
        dynamic: {
            files: [{
                expand: true,
                cwd: 'images/',
                src: ['**/*.{png,jpg,gif}'],
                dest: 'images/build/'
            }]
        }
    }

Убедимся, что он запускается:

    grunt.registerTask('default', ['concat', 'uglify', 'imagemin']);

Запускаем `grunt` и наблюдаем великолепие сжимания изображений:

![Скукоженные изображения][14]

Вам должно быть по душе, как производительность увеличивается практически без
усилий.

## Будем чуть умнее и автоматизируем процесс

То, что мы уже сделали, очень круто и невероятно полезно. Но есть ещё пара
вещей, которые можно сделать умнее, и тем самым облегчить процесс как для себя,
так и для Grunt.

1.  Запускать эти задачи автоматически, когда необходимо;
2.  Запускать только те задачи, которые нужны.

Например:

1.  Объединять и минифицировать JavaScript когда JavaScript изменился;
2.  Оптимизировать изображения когда новое изображение добавилось, или старое
    изменилось.

Мы можем добиться этого, отслеживая изменения файлов. Мы можем сказать Grunt
приглядывать за определенными изменениями, и потом, когда они произошли,
запускать определённые задачи. Отслеживание производится при помощи официального
плагина [grunt-contrib-watch][15].

Я позволю Вам установить его самостоятельно. Процесс установки в точности такой
же, как и у предыдущих плагинов, что мы установили. Настроим его, указав в
свойстве `watch` конкретные файлы (или папки, или и то и другое), которые нужно
отслеживать. Под отслеживанием я имею в виду наблюдение за изменением файлов, их
удалением и добавлением. Затем мы указываем, какие задачи необходимо запустить,
если такое изменение произошло.

Мы бы хотели, чтобы задачи объединения и минификации запускались когда
что-нибудь поменялось в папке */js/*. Когда это случится, нам нужно запустить
задачи, связанные с JavaScript. А когда что-нибудь произойдёт в другом месте,
нам, наоборот, *не* нужно запускать задачи, связанные с JavaScript, потому как
это будет бесполезно. Итак:

    watch: {
        scripts: {
            files: ['js/*.js'],
            tasks: ['concat', 'uglify'],
            options: {
                spawn: false,
            },
        }
    }

Довольно комфортно, да? Единственная непонятная вещь — это `spawn`. И знаете,
что? Я даже не знаю, что это значит. Я так понял из документации, что это
умная настройка по умолчанию. Мы разрабатываем, живя в реальном мире. Просто не
трогайте эту настройку, пока всё работает, а если не работает, изучите
документацию.

**Примечание:** Грустно, когда что-то так просто выглядит в учебнике, но у Вас
работать не хочет, не так ли? Если Вы не можете заставить Grunt после каких-то
изменений, то, скорее всего, причина этому синтаксическая ошибка в
*Gruntfile.js*. Это может выглядеть в терминале примерно так:

![Ошибка при запуске Grunt][16]

Обычно Grunt неплохо объясняет, что пошло не так, так что не забывайте читать
сообщения об ошибках. В этом случае произошла ошибка синтаксиса, меня подвела
пропущенная запятая. Нужно вернуть эту запятую на место, и всё снова работает.

## Делаем так, чтобы Grunt делал препроцессинг

Последний пункт нашего списка из начала статьи — использование Sass. И вновь
Grunt хорошо для этого подходит. Но как это? Разве Sass работает не на Ruby?
Да, это так. Есть [версия Sass, работающая на Node][17], она не добавляет в
проект дополнительных зависимостей, но не такая свежая по сравнению с версией на
Ruby. Так что, мы будем использовать официальный плагин
[grunt-contrib-sass][18], который просто считает, что Sass на Вашей машине уже
установлен. Если это не так,
[следуйте этой инструкции для командной строки][19].

Что круто в Sass, так это то, что он может производит объединение файлов и
минификацию сам по себе. Так что в нашем маленьком проекте мы можем просто
скомпилировать им наш основной файл *global.scss*:

    sass: {
        dist: {
            options: {
                style: 'compressed'
            },
            files: {
                'css/build/global.css': 'css/global.scss'
            }
        }
    }

Нам бы не хотелось запускать эту задачу вручную. У нас уже есть плагин для 
отслеживания изменений, и давайте его применим! В конфигурации `watch` добавим
ещё одну подзадачу:

    css: {
        files: ['css/*.scss'],
        tasks: ['sass'],
        options: {
            spawn: false,
        }
    }

Готово. Теперь всякий раз, как мы внесём изменения в наши файлы Sass, CSS будет
автоматически обновлён.

Давайте пойдём немного дальше (это определённо того стоит) и добавим LiveReload.
С LiveReload Вам больше не придётся переключаться в окно браузера и обновлять
страницу. Страница будет обновляться автоматически, а в случае CSS новые стили
будут внедряться в страницу даже перезагрузки (полезно для тех сайтов, где
страницы зависят от состояния).

Это очень просто устроить, потому как LiveReload уже включён в плагин watch.
Всё, что нам надо сделать:

1.  Установить [плагин для браузера][20];
2.  Добавить пару строк в настройки `watch`:
        watch: {
            options: {
                livereload: true,
            },
            scripts: {
            /* и т.д. */

3.  Перезапустить браузер и щёлкнуть на иконку LiveReload, чтобы включить его;
4.  Отредактировать файл Sass и увидеть, как изменения появляются на странице
    автоматически.

![Страница обновляется на лету][21]

Конфетка.

## Получаем level-up

Можете представить, какое море всяческих улучшений для Вашего рабочего процеса
Вам ещё доступно? Наверняка, это станет [должностью на полный рабочий день][22]
в некоторых организациях.

Какие-нибудь заумные приверженцы DevOps могут смотреть свысока на нашу
простенькую настройку. Но я бы посоветовал им умерить пыл. Даже то, что мы
сделали, уже чрезвычайно значимо. И не забывайте, это всё бесплатно и с
открытыми исходниками, и это поразительно.

Получить level-up Вы можете, используя эти полезные задачи Grunt:

*   Обработка CSS [Автопрефиксером][23] (Пятёрка с плюсом, рекомендую)
    вместо аддонов препроцессора.
*   Написание и запуск юнит-тестов JavaScript (например, [Jasmine][24]).
*   Создание спрайтов и иконок SVG автоматически (например, [Grunticon][25]).
*   Запуск сервера, чтобы Вы смогли подключать на страницу ресурсы с нужными
    путями и использовать сервисы, требующие настоящие URL, вроде TypeKit и
    подобного, и не нужно было использовать другие похожие утилиты, вроде MAMP.
*   Поиск проблем в коде при помощи [HTML-Inspector][26], [CSS Lint][27], или
    [JS Hint][28].
*   Помощь в работе с репозиториями систем контроля версий, например, с GitHub.
*   Добавление номеров версий в имена файлов Ваших ресурсов (проталкивание
    кэша).
*   Помощь в сборке на стейджинге или продакшне (например, [DPLOY][29]).

А также Вы можете левелапнуться просто глубже понимая сам Grunt:

## Делимся знаниями

Я думаю, под конец было бы неплохо немного поделится знаниями с другими.
Если Вы установили Grunt в первый раз (или помните, как это делали), будьте
особенно внимательны к неприятным мелочам, которые вы испытали и превозмогли.
Это — те мелочи, которыми следует поделиться тут, в комментариях. Так мы сделаем
из этой статьи полезный ресурс, помогающий преодолеть эти неприятные моменты без
какого-либо смущения. Мы все, вместе, занимаемся этой штукой!

Возможно, неплохим посредником станет аддон [Grunt DevTools][30] для Chrome.

 [1]: http://gruntjs.com/
 [2]: http://nodejs.org/
 [3]: img/package-json-file.gif
 [4]: https://npmjs.org/
 [5]: img/drag-folder.gif
 [6]: img/node_modules.gif
 [7]: https://github.com/chriscoyier/My-Grunt-Boilerplate
 [8]: https://github.com/gruntjs/grunt-contrib-concat
 [9]: https://github.com/gruntjs/grunt-contrib-concat#usage-examples

 [10]: https://github.com/chriscoyier/My-Grunt-Boilerplate/blob/master/Gruntfile.js
 [11]: https://github.com/gruntjs/grunt-contrib-uglify
 [12]: img/uglify-code.gif
 [13]: https://github.com/gruntjs/grunt-contrib-imagemin
 [14]: img/squished-images.gif
 [15]: https://github.com/gruntjs/grunt-contrib-watch
 [16]: img/error-running-grunt.gif
 [17]: https://github.com/sindresorhus/grunt-sass
 [18]: https://github.com/gruntjs/grunt-contrib-sass
 [19]: http://sass-lang.com/install

 [20]: http://feedback.livereload.com/knowledgebase/articles/86242-how-do-i-install-and-use-the-browser-extensions-
 [21]: img/style-injection.gif
 [22]: http://www.smashingmagazine.com/2013/06/11/front-end-ops/
 [23]: http://css-tricks.com/autoprefixer/
 [24]: https://github.com/pivotal/jasmine
 [25]: https://github.com/filamentgroup/grunticon
 [26]: http://philipwalton.com/articles/introducing-html-inspector/
 [27]: http://csslint.net/
 [28]: http://www.jshint.com/
 [29]: http://leanmeanfightingmachine.github.io/dploy/
 [30]: https://github.com/vladikoff/grunt-devtools